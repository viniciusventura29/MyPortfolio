---
interface Props {
  user?: { label: string; icon?: string };
  agent?: { label: string; icon?: string };
  gateway: { label: string; icon?: string };
  mcps: { id: string; label: string; icon?: string }[];
  title?: string;
}

const { user, agent, gateway, mcps, title } = Astro.props;
---

<div class="network-mesh">
  {title && <p class="mesh-title">{title}</p>}
  
  <div class="mesh-container">
    <!-- SVG connections -->
    <svg class="mesh-svg" viewBox="0 0 400 440" preserveAspectRatio="xMidYMid meet">
      <!-- Glow filter -->
      <defs>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="3" result="blur"/>
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
        <linearGradient id="lineGradientVertical" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stop-color="#0D5C4B" stop-opacity="0.3"/>
          <stop offset="50%" stop-color="#0D5C4B" stop-opacity="0.7"/>
          <stop offset="100%" stop-color="#0D5C4B" stop-opacity="0.3"/>
        </linearGradient>
        <linearGradient id="lineGradientRadial" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="#0D5C4B" stop-opacity="0.6"/>
          <stop offset="100%" stop-color="#1A7D68" stop-opacity="0.4"/>
        </linearGradient>
      </defs>
      
      <!-- User to Agent connection -->
      {user && agent && (
        <g class="connection-line" style="animation-delay: 0ms">
          <line 
            x1="200" y1="45" 
            x2="200" y2="130"
            stroke="url(#lineGradientVertical)"
            stroke-width="2"
            stroke-linecap="round"
          />
          <circle class="pulse-dot" r="4" fill="#0D5C4B" filter="url(#glow)">
            <animateMotion dur="1.5s" repeatCount="indefinite">
              <mpath href="#path-user-agent"/>
            </animateMotion>
          </circle>
          <path id="path-user-agent" d="M200,45 L200,130" fill="none" stroke="none"/>
        </g>
      )}
      
      <!-- Agent to Gateway connection -->
      {agent && (
        <g class="connection-line" style="animation-delay: 200ms">
          <line 
            x1="200" y1="175" 
            x2="200" y2="260"
            stroke="url(#lineGradientVertical)"
            stroke-width="2"
            stroke-linecap="round"
          />
          <circle class="pulse-dot" r="4" fill="#0D5C4B" filter="url(#glow)">
            <animateMotion dur="1.5s" repeatCount="indefinite" begin="0.3s">
              <mpath href="#path-agent-gateway"/>
            </animateMotion>
          </circle>
          <path id="path-agent-gateway" d="M200,175 L200,260" fill="none" stroke="none"/>
        </g>
      )}
      
      <!-- Gateway to MCPs connections -->
      {mcps.map((_, index) => {
        const totalMcps = mcps.length;
        const spreadAngle = 140;
        const startAngle = 90 - spreadAngle / 2;
        const angleStep = spreadAngle / (totalMcps - 1 || 1);
        const angle = totalMcps === 1 ? 90 : startAngle + (index * angleStep);
        const radian = angle * Math.PI / 180;
        const endX = 200 + Math.cos(radian) * 120;
        const endY = 290 + Math.sin(radian) * 100;
        
        return (
          <g class="connection-line" style={`animation-delay: ${400 + index * 150}ms`}>
            <line 
              x1="200" y1="290" 
              x2={endX} y2={endY}
              stroke="url(#lineGradientRadial)"
              stroke-width="2"
              stroke-linecap="round"
            />
            <circle 
              class="pulse-dot"
              r="4"
              fill="#1A7D68"
              filter="url(#glow)"
            >
              <animateMotion 
                dur="2s" 
                repeatCount="indefinite"
                begin={`${0.5 + index * 0.3}s`}
              >
                <mpath href={`#path-mcp-${index}`}/>
              </animateMotion>
            </circle>
            <path 
              id={`path-mcp-${index}`} 
              d={`M200,290 L${endX},${endY}`} 
              fill="none" 
              stroke="none"
            />
          </g>
        );
      })}
      
      <!-- Mesh connections between MCPs (subtle) -->
      {mcps.length > 1 && mcps.map((_, index) => {
        if (index === mcps.length - 1) return null;
        const totalMcps = mcps.length;
        const spreadAngle = 140;
        const startAngle = 90 - spreadAngle / 2;
        const angleStep = spreadAngle / (totalMcps - 1 || 1);
        
        const angle1 = startAngle + (index * angleStep);
        const angle2 = startAngle + ((index + 1) * angleStep);
        const radian1 = angle1 * Math.PI / 180;
        const radian2 = angle2 * Math.PI / 180;
        const x1 = 200 + Math.cos(radian1) * 120;
        const y1 = 290 + Math.sin(radian1) * 100;
        const x2 = 200 + Math.cos(radian2) * 120;
        const y2 = 290 + Math.sin(radian2) * 100;
        
        return (
          <line 
            class="outer-connection"
            x1={x1} y1={y1} 
            x2={x2} y2={y2}
            stroke="#2D3D3F"
            stroke-width="1"
            stroke-dasharray="4 4"
            style={`animation-delay: ${700 + index * 100}ms`}
          />
        );
      })}
    </svg>
    
    <!-- User node -->
    {user && (
      <div class="user-node">
        <div class="node-wrapper">
          <div class="user-circle">
            {user.icon && <span class="node-icon">{user.icon}</span>}
          </div>
          <span class="node-label">{user.label}</span>
        </div>
      </div>
    )}
    
    <!-- Agent node -->
    {agent && (
      <div class="agent-node">
        <div class="node-wrapper">
          <div class="agent-box">
            {agent.icon && <span class="node-icon-large">{agent.icon}</span>}
          </div>
          <span class="node-label">{agent.label}</span>
        </div>
      </div>
    )}
    
    <!-- Gateway node (center) -->
    <div class="gateway-node">
      <div class="gateway-wrapper">
        <!-- Pulsing ring -->
        <div class="gateway-ring"></div>
        <div class="gateway-glow"></div>
        
        <div class="gateway-circle">
          {gateway.icon && (
            <span class="gateway-icon">{gateway.icon}</span>
          )}
          <span class="gateway-label">{gateway.label}</span>
        </div>
      </div>
    </div>
    
    <!-- MCP nodes -->
    {mcps.map((mcp, index) => {
      const totalMcps = mcps.length;
      const spreadAngle = 140;
      const startAngle = 90 - spreadAngle / 2;
      const angleStep = spreadAngle / (totalMcps - 1 || 1);
      const angle = totalMcps === 1 ? 90 : startAngle + (index * angleStep);
      const radian = angle * Math.PI / 180;
      // Convert SVG coords to percentages
      const x = 50 + (Math.cos(radian) * 30);
      const y = 66 + (Math.sin(radian) * 23);
      
      return (
        <div 
          class="mcp-node"
          style={`left: ${x}%; top: ${y}%; animation-delay: ${index * 100}ms`}
          data-mcp={mcp.id}
        >
          <div class="mcp-box">
            {mcp.icon && (
              <span class="mcp-icon">{mcp.icon}</span>
            )}
            <span class="mcp-label">{mcp.label}</span>
          </div>
        </div>
      );
    })}
  </div>
</div>

<style>
  .network-mesh {
    margin: 3rem 0;
    width: 100%;
  }

  .mesh-title {
    text-align: center;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    color: #5A5A5A;
    margin-bottom: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-weight: 500;
  }

  .mesh-container {
    position: relative;
    width: 100%;
    max-width: 500px;
    margin: 0 auto;
    aspect-ratio: 1 / 1.1;
    min-height: 380px;
  }

  .mesh-svg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .user-node {
    position: absolute;
    left: 50%;
    top: 0;
    transform: translateX(-50%);
    z-index: 10;
    animation: scaleIn 0.5s ease-out forwards;
  }

  .agent-node {
    position: absolute;
    left: 50%;
    top: 22%;
    transform: translateX(-50%);
    z-index: 10;
    animation: scaleIn 0.5s ease-out forwards;
    animation-delay: 100ms;
  }

  .gateway-node {
    position: absolute;
    left: 50%;
    top: 52%;
    transform: translateX(-50%);
    z-index: 20;
    animation: scaleIn 0.5s ease-out forwards;
    animation-delay: 200ms;
  }

  .node-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .user-circle {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: #0D5C4B;
    border: 2px solid #1A7D68;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(13, 92, 75, 0.3);
  }

  .agent-box {
    width: 64px;
    height: 64px;
    background: #0D5C4B;
    border: 2px solid #1A7D68;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(13, 92, 75, 0.3);
  }

  .node-icon {
    font-size: 1.25rem;
  }

  .node-icon-large {
    font-size: 1.5rem;
  }

  .node-label {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 500;
    color: #1A1A1A;
  }

  .gateway-wrapper {
    position: relative;
  }

  .gateway-ring {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: rgba(13, 92, 75, 0.2);
    animation: ping-slow 2s cubic-bezier(0, 0, 0.2, 1) infinite;
  }

  .gateway-glow {
    position: absolute;
    inset: -8px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(13, 92, 75, 0.2), transparent);
    filter: blur(8px);
  }

  .gateway-circle {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(135deg, #0D5C4B, #0A4A3C);
    border: 2px solid #1A7D68;
    box-shadow: 0 8px 24px rgba(13, 92, 75, 0.4);
  }

  .gateway-icon {
    font-size: 1.5rem;
  }

  .gateway-label {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.5rem;
    font-weight: 700;
    color: #E8E4DE;
    text-align: center;
    margin-top: 0.25rem;
    padding: 0 0.25rem;
    line-height: 1.2;
  }

  .mcp-node {
    position: absolute;
    z-index: 10;
    transform: translate(-50%, -50%);
    animation: fadeInScale 0.4s ease-out forwards;
    opacity: 0;
  }

  .mcp-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    padding: 0.75rem;
    background: #F5F2ED;
    border: 1px solid #0D5C4B;
    transition: all 0.3s ease;
    cursor: default;
  }

  .mcp-box:hover {
    background: rgba(13, 92, 75, 0.05);
    border-color: #1A7D68;
    transform: scale(1.05);
  }

  .mcp-icon {
    font-size: 1.25rem;
    transition: transform 0.3s ease;
  }

  .mcp-box:hover .mcp-icon {
    transform: scale(1.1);
  }

  .mcp-label {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 500;
    color: #1A1A1A;
    text-align: center;
    white-space: nowrap;
  }

  .connection-line {
    opacity: 0;
    animation: fadeIn 0.6s ease-out forwards;
  }

  .outer-connection {
    opacity: 0;
    animation: fadeIn 0.4s ease-out forwards;
  }

  .pulse-dot {
    opacity: 0.8;
  }

  @keyframes scaleIn {
    from { 
      opacity: 0;
      transform: translateX(-50%) scale(0.5);
    }
    to { 
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }
  }

  @keyframes fadeInScale {
    from { 
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.8);
    }
    to { 
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes ping-slow {
    0% {
      transform: scale(1);
      opacity: 0.5;
    }
    75%, 100% {
      transform: scale(1.5);
      opacity: 0;
    }
  }
</style>
